"""Command line utilities"""
from __future__ import absolute_import
from .utils import _wrap_run_cmd
from .status import str_status
from . import JobScript, AsyncResult, __version__
import importlib
import sys
import os
import logging
import click


DEFAULT_TEST_BODY = r'''
echo "####################################################"
echo "Job id         : $CLUSTERJOB_ID"
echo "Job name       : $CLUSTERJOB_NAME"
echo "Workdir        : $CLUSTERJOB_WORKDIR"
echo "Submission Host: $CLUSTERJOB_SUBMIT_HOST"
echo "Compute Node   : $CLUSTERJOB_NODELIST"
echo "Job started on" `hostname` `date`
echo "Current directory:" `pwd`
echo "####################################################"

sleep 60

echo "Job Finished: " `date`
exit 0
'''

def _print_default_test_body(ctx, param, value):
    if not value or ctx.resilient_parsing:
        return
    click.echo(DEFAULT_TEST_BODY)
    ctx.exit()


def _run_testing_workflow(job, prompt=True):
    """For the given job, interactively go through the workflow of submitting,
    canceling, resubmitting, and polling the job (while it runs and after it
    ends). Giving ``prompt=False`` indicates "replay" mode.
    """
    click.echo("\n*** Submitting Job ***\n")
    ar = job.submit()
    if prompt:
        click.pause("\nPlease verify that job has been submitted. "
                    "Press Enter to continue")

    click.echo("\n*** Cancelling Job ***\n")
    ar.cancel()
    if prompt:
        click.pause("\nPlease verify that job has been cancelled. "
                    "Press Enter to continue")

    click.echo("\n*** Resubmitting Job ***\n")
    ar = job.submit(retry=True)
    if not prompt:
        ar.max_sleep_interval = 0
        # this relies on test_workflow monkeypatching the _min_sleep_interval
        # to 0
    if prompt:
        click.pause("\nPlease verify that job has been resubmitted. "
                    "Press Enter to continue")
    click.echo("\nStatus of running job: "+str_status[ar.status])
    if prompt:
        click.pause("\nPlease wait for job to finish. "
                    "Press Enter to continue")
    click.echo("\nStatus of finished job: "+str_status[ar.get()])


@click.command()
@click.help_option('-h', '--help')
@click.version_option(version=__version__)
@click.option('--body', help="File containing the body of the script to be "
    "used. If not given, a default script will be used , see "
    "--show-default-body.", type=click.Path(exists=True))
@click.option('--backend_module', '-m', metavar='MOD', help="Module from "
    "which to load a custom backend")
@click.option('--show-default-body', is_flag=True, help="Print the default "
              "script body and exit.", callback=_print_default_test_body,
              expose_value=False, is_eager=True)
@click.argument('inifile', type=click.Path(exists=True))
def test_backend(inifile, body, backend_module):
    """Perform a workflow test for a backend/job configuration specified in
    INIFILE. Create a clusterjob.JobScript instance of a simple default script
    (or any other script specified via --body). Read settings from the INIFILE
    (see JobScript.read_settings method). The INIFILE may refer to a custom
    backend loaded via the '-m' option: E.g. `-m mymod` is equivalent to
    the Python code

        \b
        import mymod; JobScript.register_backend(mymod.backend)

    See the clusterjob documentation for details.

    \b
    Interactively guide through the following workflow:
    * Submit the job script.
    * Cancel the submitted job.
    * Re-submit the job script.
    * Poll the job status while it is running.
    * Wait for job to end, poll job status after job has ended.

    The script used for the test should have a run time of at least 1 minute,
    in order to allow for interactively checking the successful operations of
    the script. Assuming the INIFILE is named `<basename>.ini`, the following
    files will be generated:

    \b
    * <basename>.body.sh: the original script body (If --body is given, this
      will be a copy of the file specified there)
    * <basename>.rendered.sh: the rendered script, i.e. with backend-specific
      resource headers, and with inserted placeholders
    * <basename>.out: the output generated by the scheduler, via the 'stdout'
      resource specification. Note that a 'stdout' specified in INIFILE will
      be overwritten to the value 'clusterjob_test.out'
    * <basename>.json: a record of the communication with the scheduler
      during the workflow

    The above set of files may be added to the clusterjob test suite, by moving
    them to `clusterjob/tests/test_workflow/` and by adding the INIFILE to the
    INI_FILES list in `clusterjob/tests/test_workflow.py`. By using the
    information recorded in the json file, the test suite will then be able to
    re-run the workflow without actually connecting to the scheduler.
    """

    click.clear()
    click.echo("\nSTART WORKFLOW TEST -- RECORDING MODE\n")

    logging.basicConfig(level=logging.WARNING)
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    if backend_module is not None:
        click.echo("Loading backend from %s.backend" % backend_module)
        mod = importlib.import_module(backend_module)
        JobScript.register_backend(mod.backend)
        click.echo("")

    basename = os.path.splitext(inifile)[0]
    jsonfile     = basename + ".json"
    outfile      = basename + ".out"
    bodyfile     = basename + ".body.sh"
    renderedfile = basename + ".rendered.sh"
    files = [inifile, jsonfile, outfile, bodyfile, renderedfile]
    if body is not None:
        click.echo("Reading body from %s" % body)
        with open(body) as in_fh:
            body_str = in_fh.read()
    else:
        click.echo("Using default body:\n")
        click.echo("------------------------&<-------------------------------")
        click.echo(DEFAULT_TEST_BODY)
        click.echo("------------------------&<-------------------------------")
        body_str = DEFAULT_TEST_BODY
    if body != bodyfile:
        click.pause("\nBody will be written to %s. Press ENTER to confirm."
                    % bodyfile)
        with open(bodyfile, 'w') as out_fh:
            out_fh.write(body_str)
        click.clear()

    JobScript.debug_cmds = True
    JobScript._run_cmd = staticmethod(_wrap_run_cmd(jsonfile, 'record'))
    AsyncResult._run_cmd = staticmethod(JobScript._run_cmd)

    # configure job script
    job = JobScript(body_str, jobname='test_clj')
    click.echo("\nConfiguring job from %s\n" % inifile)
    try:
        job.read_settings(inifile)
    except ValueError as exc_info:
        click.echo("\nERROR while loading %s: %s"
                   % (inifile, str(exc_info)))
        sys.exit(1)
    stdout = 'clusterjob_test.out'
    job.resources['stdout'] = stdout

    # set up epilogue to get us the script output
    epilogue = ''
    has_epilogue = False
    if len(job.epilogue) > 0:
        has_apilogue = True
        epilogue = job.epilogue + "\n"
    if job.remote is None:
        local_out = '{rootdir}/{workdir}/' + stdout
        epilogue += 'cp %s %s' % (local_out, outfile)
    else:
        remote_out = '{remote}:{rootdir}/{workdir}/' + stdout
        epilogue += 'rsync -av %s %s' % (remote_out, outfile)
    epilogue += "\n" + 'echo ""; echo "STDOUT:"; cat ' + outfile
    job.epilogue = epilogue
    has_prologue = False
    if len(job.prologue) > 0:
        has_prologue = True

    if len(body_str.splitlines()) < 20:
        click.echo("\nRendered job script:\n")
        click.echo("------------------------&<-------------------------------")
        click.echo(str(job))
        click.echo("------------------------&<-------------------------------")
    else:
        click.pause("\nPress ENTER to view rendered job script.")
        click.echo_via_pager(str(job))
    click.pause(("\nRendered job script will be written to %s. Press ENTER "
                 "to confirm.") % renderedfile)
    with open(renderedfile, 'w') as out_fh:
        out_fh.write(str(job))
    click.clear()

    _run_testing_workflow(job, prompt=True)

    click.pause(("\nThe job output has been recorded in %s. Press ENTER to "
                 "view file") % outfile)
    with open(outfile) as in_fh:
        click.echo_via_pager(in_fh.read())
    click.clear()
    click.echo("\nThe interaction has been recorded in %s" % jsonfile)
    if job.remote is None:
        click.echo(("\nIf you intend to add %s to the clusterjob test suite, "
                    "you may have to take into acount that the tuest suite "
                    "will set $HOME to '/home/clusterjob_test', instead "
                    "of '%s'") % (jsonfile, os.environ['HOME']))
        if click.confirm("\nDo you want to edit %s now?" % jsonfile):
            click.edit(filename=jsonfile)

    click.echo("\nYou can now add this test to the clusterjob test suite. "
               "Please move the files %s to clusterjob/tests/test_workflow/, "
               "and add %s to the INI_FILES list in "
               "clusterjob/tests/test_workflow.py" % (str(files), inifile))

    if has_epilogue or has_prologue:
        click.echo("\nNOTE THAT IN THE TEST SUITE ANY EPILOGUE OR "
                   "PROLOGUE WILL BE DISABLED.")

    click.pause("\nPress Enter to finish")

    click.echo("\n\nFINISHED WORKFLOW TEST -- RECORDING MODE\n")
